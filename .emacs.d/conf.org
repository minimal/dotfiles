#+STARTUP: content
#+OPTIONS: toc:4 h:4
#+TITLE: Emacs configuration

This document is the result of me wanting to test literate programming
and thinking that my emacs configuration was the perfect candidate. It
is directly inspired by [[http://sachachua.com/blog/2012/06/literate-programming-emacs-configuration-file/][a blog post]] by Sacha Chua and others.

“C-c '” in a source block runs org-edit-special

* General
  helm, ido etc

** Settings

*** Mac specific.

   https://github.com/purcell/exec-path-from-shell is essential

   #+begin_src emacs-lisp :tangle yes
     ;; Are we on a mac?
     (setq is-mac (equal system-type 'darwin))

     ;; magnars stuff
     (when is-mac
       ;; mac friendly font
       ;;(set-face-attribute 'default nil :font "Monaco-12")
       (set-face-attribute 'default nil :font "PragmataPro-13")

       ;; Ignore .DS_Store files with ido mode
       (add-to-list 'ido-ignore-files "\\.DS_Store")
       ;; Don't open files from the workspace in a new frame
       (setq ns-pop-up-frames nil)
       ;; Use aspell for spell checking: brew install aspell --lang=en
       (setq ispell-program-name "/usr/local/bin/aspell")
       ;; (global-set-key (kbd "<kp-delete>") 'delete)
       (global-set-key '[(control kp-delete)] 'kill-word)

       (use-package exec-path-from-shell
         :ensure t
         :init (exec-path-from-shell-initialize)))
   #+end_src

*** Tab widths, recentf etc

   #+begin_src emacs-lisp :tangle yes
     (setq-default tab-width 4)
     (setq-default whitespace-tab-width 4)
     (setq column-number-mode t)
     (setq js-indent-level 4)
     (setq recentf-max-menu-items 50)
     (setq recentf-auto-cleanup 'never) ;; disable before we start recentf!
     (global-linum-mode 1)
     (setq linum-format " %d  ")  ;; reduce glitching with fring
     (menu-bar-mode 1)
     (setq-default cursor-type 't)
     (winner-mode 1) ;; C-c left => undo window layout change, C-c right => ;; undo
     (remove-hook 'text-mode-hook 'turn-on-auto-fill) ;; really don't want this ffs
     (turn-off-auto-fill)
     (setq confirm-kill-emacs 'y-or-n-p)
   #+end_src

   Backup
   See http://pejusdas.com/content/emacs-backup-files and
   http://amitp.blogspot.com/2007/03/emacs-move-autosave-and-backup-files.html


   #+begin_src emacs-lisp :tangle yes
     (setq kept-new-versions 5)
     (setq kept-old-versions 5)

   #+end_src

   #+begin_src emacs-lisp
     ;; http://www.emacswiki.org/emacs/SwitchingBuffers#toc5
     (defun switch-to-previous-buffer ()
       "Switch to most recent buffer. Repeated calls toggle back and
       forth between the most recent two buffers."
       (interactive)
       (switch-to-buffer (other-buffer (current-buffer) 1)))
   #+end_src

*** Global bindings
    On osx set command to meta
    #+begin_src emacs-lisp :tangle yes
      (when is-mac
        (setq mac-command-modifier 'meta)
        (setq mac-option-modifier 'super))
    #+end_src
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      ;; To unset a key e.g:
      ;; (global-unset-key (kbd "C-_"))
      ;; f1 is help prefix, press twice for help-for-help
      (bind-key "<f2>" #'goto-line)
      ;; f3 is start record macro
      ;; f4 is stop record macro / execute macro
      (bind-key "<f5>" #'previous-multiframe-window)
      (bind-key "<f6>" #'next-multiframe-window)
      (bind-key "<f7>" #'kill-buffer)
      (bind-key "<f8>" #'dired-jump)
      (bind-key "<M-f8>" #'ido-find-file)
      (bind-key "<S-f8>" #'ido-find-file-other-window)
      ;; f10 is menu-bar-open
      (bind-key "<S-f9>" #'ido-switch-buffer-other-window)
      (set-register ?e '(file . "~/.emacs.d/chris.el")) ; 'C-x r j e' opens this file
      (define-key global-map (kbd "C-;") 'iedit-mode)
      (define-key global-map (kbd "C-3") 'comment-or-uncomment-region-or-line)
      (define-key global-map (kbd "M-3") 'comment-or-uncomment-region-or-line)
      (bind-key "s-/" #'comment-or-uncomment-region-or-line)
      (global-set-key [(meta \])] 'textmate-shift-right)
      (global-set-key [(meta \[)] 'textmate-shift-left)
      ;; (global-set-key [(control q)] 'fill-paragraph) ;; virtual box
      ;; overrides meta-q

      (bind-key "C-x g" #'magit-status)
      (global-set-key [(meta m)] 'jump-char-forward)
      (global-set-key [(shift meta m)] 'jump-char-backward)
      (global-set-key [(meta i)] 'back-to-indentation)

      (global-set-key (kbd "M-K")
                      (lambda ()
                        (interactive)
                        (join-line -1)))
      (bind-key "C-}" #'cua-scroll-up)
      (bind-key "C-{" #'cua-scroll-down)


    #+end_src

****    Atreus bindings
     Some more convention bindings when you have no easy fn keys.
     Luckily I have been massively underutilising the super key.

     #+begin_src emacs-lisp
       (bind-key "s-y" #'previous-multiframe-window)
       (bind-key "s-h" #'next-multiframe-window)
       (bind-key "s-u" #'revert-buffer)
       (bind-key "s-k" #'kill-this-buffer)
       (bind-key "s-i" #'helm-mini)
       (bind-key "s-o" #'switch-to-previous-buffer)
       (bind-key "s-p" #'helm-projectile-find-file-and-recent)
       (bind-key "s-;" #'helm-semantic-or-imenu)
     #+end_src

** Use package
   This is a better way to fetch and load packages You should
   keep :init forms as simple as possible, and put as much as you can
   get away with on the :config side. Config doesn't run till the mode
   is activated.

   Version 2 notes:
   #+BEGIN_QUOTE

   The meaning of :init has been changed: It now always happens before
   package load, whether :config has been deferred or not. This means
   that some uses of :init in your configuration may need to be
   changed to :config (in the non-deferred case). For the deferred
   case, the behavior is unchanged from before.

   Also, because :init and :config now mean "before" and "after",
   the :pre- and :post- keywords are gone, as they should no longer be
   necessary
   #+END_QUOTE

** Paradox
   Better package menu.

   #+begin_src emacs-lisp :tangle yes
     (use-package paradox
       :ensure t
       :commands (paradox-list-packages)
       :config (paradox-enable))
   #+end_src

** ido
   Not used much now after helm but make sure it is vertical and has
   normal navigation.

   #+BEGIN_SRC emacs-lisp
     (use-package ido-vertical-mode
       :ensure t
       :init (ido-vertical-mode 1)
       :config (progn
                 (setq ido-vertical-define-keys 'C-n-and-C-p-only)
                 (setq ido-vertical-show-count t)))

   #+END_SRC

** helm
   Use for a lot of things, buffer swithing, finding files, searching
   for words.

   More options at http://pages.sachachua.com/.emacs.d/Sacha.html#unnumbered-14

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package helm
       :ensure helm
       :diminish helm-mode
       :config
       (progn
         (setq helm-quick-update t
               helm-ff-skip-boring-files t
               helm-locate-command "mdfind %s %s")
         ;; need bind-key* to override prjectile bindings
         (bind-key* "C-c p f" #'helm-projectile-find-file-and-recent)
         (helm-mode))
       :bind (("<f9>" . helm-mini)
              ("C-x b" . helm-mini)
              ("M-<f9>" . helm-projectile-find-file-and-recent)
              ("M-S-<f9>" . helm-projectile)
              ("C-x a g" . helm-projectile-ag)
              ("<f11>" . helm-semantic-or-imenu)
              ("M-x" . helm-M-x)))
   #+END_SRC

*** helm-swoop

    Very good in-buffer searching

    #+begin_src emacs-lisp :tangle yes
      (use-package helm-swoop
        :ensure t
        :bind
        (("C-M-s" . helm-swoop)
         ;; ("C-S-s" . helm-swoop)
         ;; ("M-i" . helm-swoop)
         ;; ("M-s s" . helm-swoop)
         ;; ("M-s M-s" . helm-swoop)
         ("M-I" . helm-swoop-back-to-last-point)
         ("C-c M-i" . helm-multi-swoop)
         ("C-x M-i" . helm-multi-swoop-all))
        :init
        (define-key isearch-mode-map (kbd "M-i") #'helm-swoop-from-isearch)
        :config
        (progn
          (define-key helm-swoop-map (kbd "M-i") #'helm-multi-swoop-all-from-helm-swoop)))
    #+end_src

*** Ag for helm

    #+begin_src emacs-lisp :tangle yes
      (use-package helm-ag
        :ensure t
        :commands (helm-ag))

      ;; realtime
      (use-package helm-ag-r
        :ensure t
        :commands (helm-ag-r))
    #+end_src

*** projectile

    Allows operations within projects (e.g. git repo). Good
    integration with helm.

    Use custom command for recent files in project and then all files
    in project.

    #+begin_src emacs-lisp :tangle yes
      (use-package helm-projectile
        :ensure helm-projectile)

      (use-package projectile
        :ensure projectile
        :diminish projectile-mode
        :bind (("C-c p w" . helm-projectile-switch-project))
        :init
        (progn
          ;; (setq projectile-keymap-prefix (kbd "C-c p"))
          ;; (setq projectile-completion-system 'default)
          (helm-projectile-command "find-file-and-recent"
                                   '(helm-source-projectile-recentf-list
                                     helm-source-projectile-files-list)
                                   "Find file or recent: ")
          (setq projectile-enable-caching t)
          (projectile-global-mode)))

    #+end_src

*** org mode
    org-replace-disputed-keys has to actually run before org.el is
    loaded. So it is also before this file.
    #+begin_src emacs-lisp :tangle yes
      ;; Don't ruin S-arrow to switch windows please (use M-+ and M-- instead to toggle)
      (setq org-replace-disputed-keys t)

      ;; Fontify org-mode code blocks
      (setq org-src-fontify-natively t)

      ;; Log done time
      (setq org-log-done t)

      ;; material theme and linum are causing  count-screen-lines error
      (add-hook 'org-mode-hook
                (lambda () (linum-mode -1)))


      (bind-key "<s-return>" #'org-meta-return  org-mode-map)

      (setq org-default-notes-file (concat org-directory "/todo-august-2014.org"))
      (setq org-refile-targets '((org-agenda-files . (:level . 1))))
      ;; why doesn't this load automatically?
      (setq org-capture-templates
            '(("t" "Todo" entry (file+headline org-default-notes-file "Tasks")
               "* TODO %?\n  %i\n %t %a")
              ("T" "Clock-in Task" entry
                    (file+headline org-default-notes-file "Tasks")
                    "* TODO %?\n"
                    :clock-in t
                    :clock-resume t)
              ("n" "Note (plain)" entry
               (file+headline org-default-notes-file "Notes")
               "* %?\n")
              ("N" "Note (rich)" entry
               (file+headline org-default-notes-file "Notes")
               "* %?\n %a")
              ("v" "inventory item" entry (file+headline (concat org-directory "/inventory.org_archive") "Things")
                                            "** %? :UNCATEGORIZED:
      :PROPERTIES:
      :LOCATION: %^{LOCATION}p
      :QUANTITY: %^{QUANTITY}p
      :VALUE: %^{VALUE}p
      :ACQUIRED_ON: %^t
      :URL: %l
      :END:" :clock-in f)))
    #+end_src

** Small utils
*** Drag stuff
    Move region up or down

    #+begin_src emacs-lisp :tangle yes
      (use-package drag-stuff
        :ensure t
        :bind
        (("M-n" . drag-stuff-down)
         ("M-p" . drag-stuff-up))
        :init
        (progn
          (drag-stuff-global-mode)))
    #+end_src

*** Ace jump mode

    #+begin_src emacs-lisp :tangle yes
      (use-package ace-jump-mode
        :ensure t
        :bind (("M-#" . ace-jump-mode)))
    #+end_src

    Zap is useful
    http://sachachua.com/blog/2014/12/emacs-kaizen-ace-jump-zap-lets-use-c-u-zap-character/
    #+begin_src emacs-lisp :tangle yes
      (use-package ace-jump-zap
        :ensure ace-jump-zap
        :bind
        (("M-z" . ace-jump-zap-up-to-char-dwim)
         ("C-M-z" . ace-jump-zap-to-char-dwim)))
    #+end_src

*** ace window

    #+begin_src emacs-lisp :tangle yes
      (use-package ace-window
        :ensure t
        :bind (("C-#" . ace-window)))
    #+end_src

*** Expand region
    Semantically expand and contract region

    #+begin_src emacs-lisp :tangle yes
      (use-package expand-region
        :ensure t
        :bind (("C-=" . er/expand-region)))
    #+end_src

*** Multiple cursors

    Region bindings mode with single key maps makes multiple cursors
    much better.

   #+begin_src emacs-lisp :tangle yes
     (use-package multiple-cursors
       :ensure t)

     (use-package region-bindings-mode
       :ensure t
       :config
       (progn
         (region-bindings-mode-enable)
         (setq region-bindings-mode-disable-predicates (quote ((lambda nil buffer-read-only))))
         (bind-key "a" #'mc/mark-all-like-this-dwim  region-bindings-mode-map)
         (bind-key "p" #'mc/mark-previous-like-this  region-bindings-mode-map)
         (bind-key "n" #'mc/mark-next-like-this  region-bindings-mode-map)
         (bind-key "m" #'mc/mark-more-like-this-extended  region-bindings-mode-map)
         (bind-key "s" #'mc/skip-to-next-like-this  region-bindings-mode-map))
     )

   #+end_src


*** Guide Key
    *TODO*: look at replacing with https://github.com/justbur/emacs-which-key
    #+begin_src emacs-lisp :tangle yes
      (use-package guide-key
        :ensure guide-key-tip
        :diminish guide-key-mode
        :init
        (progn
        (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-c" "C-x" "C-c p"))
        (guide-key-mode 1)))
    #+end_src

*** Quickrun
    http://ericjmritz.name/2014/12/23/using-quickrun-in-emacs/

    Try quickrun-region, quickrun-replace-region

    #+begin_src emacs-lisp :tangle yes
      (use-package quickrun
;;        :defer t
        :ensure t)
    #+end_src

*** Others

    #+begin_src emacs-lisp :tangle yes
      (use-package visual-regexp-steroids
        :ensure t)

      (use-package ethan-wspace
        :ensure t
        :init
        (progn
          (global-ethan-wspace-mode 1)
          (setq mode-require-final-newline nil)))

      (use-package volatile-highlights
        :ensure t
        :config (volatile-highlights-mode))

      (use-package highlight-indentation
        :ensure t)

      (use-package color-identifiers-mode
        :ensure t)

      (use-package popwin
        :ensure t
        :init
        (progn
          (setq display-buffer-function 'popwin:display-buffer)
          (push "*undo-tree*" popwin:special-display-config)
          ;; (push '("*Ack-and-a-half*" :height 20) popwin:special-display-config)
          (push "*vc-diff*" popwin:special-display-config)))

      (use-package textmate
        :ensure t
        :init (textmate-mode))

      ;; (use-package ace-isearch
      ;;   :ensure t
      ;;   :init (global-ace-isearch-mode nil))

      (use-package aggressive-indent
        :ensure t)

      (use-package github-browse-file
        :ensure t)

      (use-package helm-themes
        :ensure t)

    #+end_src

* Languages
** Clojure
   [[http://clojure.org/space/showimage/clojure-icon.gif]]

   Reset from any buffer and return to buffer
   #+begin_src emacs-lisp :tangle yes
     ;; Reloaded reset from any clojure buffer
     (defun cider-namespace-refresh ()
       (interactive)
       (save-some-buffers)
       (with-current-buffer (cider-current-repl-buffer)
         (cider-interactive-eval
          "(reloaded.repl/reset)")))

     (defun cider-integrant-refresh ()
       (interactive)
       (save-some-buffers)
       (with-current-buffer (cider-current-repl-buffer)
         (cider-interactive-eval
          "(integrant.repl/reset)")))
   #+end_src

   Put source in repl and run. Good for documenting repl session that
   runs code from a buffer.

   #+begin_src emacs-lisp :tangle yes
     (defun cider-eval-expression-at-point-in-repl ()
       (interactive)
       (let ((form (cider-sexp-at-point)))
         ;; Strip excess whitespace
         (while (string-match "\\`\s+\\|\n+\\'" form)
           (setq form (replace-match "" t t form)))
         (with-current-buffer (cider-current-repl-buffer)
           (goto-char (point-max))
           (insert form)
           (cider-repl-return))))
   #+end_src


   Load cider with customisations, custom test error reporting

   #+begin_src emacs-lisp :tangle yes
     (use-package cider
       :ensure t
       :commands (cider-jack-in cider)
       :config
       (progn
         (add-hook 'cider-mode-hook
                   (lambda ()
                     ;; (cider-turn-on-eldoc-mode)
                     (company-mode)
                     (bind-keys :map clojure-mode-map
                                ("C-x M-r" . cider-namespace-refresh)
                                ("C-`" . cider-eval-expression-at-point-in-repl)
                                ("<f5>" . flycheck-previous-error)
                                ("<s-return>" . "#_")
                                ("<f6>" . flycheck-next-error))

                     ))
         (add-hook 'cider-repl-mode-hook
                   (lambda ()
                     (company-mode)
                     (enable-paredit-mode)
                     (setq cider-stacktrace-fill-column t
                           cider-repl-print-length 100
                           cider-repl-history-file "~/.cache/cider-history"
                           cider-repl-wrap-history t
                           cider-repl-history-size 1000
                           )))
         ;;(require 'squiggly-clojure)
         ;;nrepl-hide-special-buffers t
         (setenv "EXPECTATIONS_COLORIZE" "false")

         (defun cider-figwheel-repl ()
           (interactive)
           (save-some-buffers)
           (with-current-buffer (cider-current-repl-buffer)
             (goto-char (point-max))
             (insert "(require 'figwheel-sidecar.repl-api)
                  (figwheel-sidecar.repl-api/start-figwheel!) ; idempotent
                  (figwheel-sidecar.repl-api/cljs-repl)")
             (cider-repl-return)))


         ;; Custom error rendering to show diffs and form from my
         ;; humane-test mods
         (comment
          (defun cider-test-render-assertion (buffer test)
            "Emit into BUFFER report detail for the TEST assertion."
            (with-current-buffer buffer
              (nrepl-dbind-response test (var context type message expected actual diffstrs test-form error)

                (cider-propertize-region (cider-intern-keys (cdr test))
                  (cider-insert (capitalize type) (cider-test-type-face type) nil " in ")
                  (cider-insert var 'font-lock-function-name-face t)
                  (when context  (cider-insert context 'font-lock-doc-face t))
                  (when message  (cider-insert message 'font-lock-doc-string-face t))
                  (when test-form (cider-insert (cider-font-lock-as-clojure test-form) nil t "\n"))
                  (when expected (cider-insert "expected: " 'font-lock-comment-face nil
                                               (cider-font-lock-as-clojure expected)))

                  (when actual   (cider-insert "  actual: " 'font-lock-comment-face)
                        (if error
                            (progn (insert-text-button
                                    error
                                    'follow-link t
                                    'action 'cider-test-stacktrace
                                    'help-echo "View causes and stacktrace")
                                   (newline))
                          (insert (cider-font-lock-as-clojure actual))))

                  (when diffstrs
                    (cider-insert "    diff: " 'font-lock-comment-face nil
                                  (cider-font-lock-as-clojure diffstrs))))
                (newline)))))
         ))

     ;; sort ns

     (defun cljr-sort-ns ()
       (interactive)
       (cljr--ensure-op-supported "clean-ns")
       (cider-eval-ns-form :sync)
       (cljr--clean-ns nil :no-pruning))
   #+end_src


   #+begin_src emacs-lisp :tangle yes
     (use-package clojure-mode
       :ensure t
       :config
       (progn
         (add-hook #'clojure-mode-hook
                   (lambda ()
                     (auto-complete-mode -1)
                     (enable-paredit-mode)
                     (aggressive-indent-mode)
                     (highlight-indentation-mode)
                     (rainbow-identifiers-mode)
                     (require 'flycheck-joker)
                     (flycheck-mode)
                     ))))


     (use-package clj-refactor
       :ensure t
       :config
       (progn
         (add-hook #'clojure-mode-hook
                   (lambda ()
                     (clj-refactor-mode)))))
   #+end_src

   Fighwheel repl with inf-clojure
   Current best solution for getting a decent cljs repl. Run from
   project root.

   Planck javascriptcore repl.

   #+begin_src emacs-lisp

     (use-package inf-clojure
       :ensure t
       :config
       (progn
         (defun cljs-fig-repl ()
           (interactive)
           (run-clojure "lein figwheel"))
         (defun cljs-planck-repl ()
           (interactive)
           (run-clojure "planck"))))


   #+end_src

*** Clojure mode indents

    #+begin_src emacs-lisp :tangle yes
      (add-hook
       #'clojure-mode-hook

       (lambda ()
         ;;(put 'defui 'clojure-backtracking-indent '(4 4 (2)))
         (put 'defui 'clojure-backtracking-indent '(1 nil nil (1)))
         ;;(put 'defcomponent 'clojure-backtracking-indent '(4 4 (2)))
         ;;(put 's/defrecord 'clojure-backtracking-indent '(4 4 (2)))
         ;; (put-clojure-indent 'this-as 1)
         (put-clojure-indent 'alet 1)
         (put-clojure-indent 'mlet 1)
         (put-clojure-indent 'div 1)
         (put-clojure-indent 'GET 2)
         (put-clojure-indent 'POST 2)
         (put-clojure-indent 'PUT 2)
         (put-clojure-indent 'ANY 2)
         (put-clojure-indent 'GET* 2)
         (put-clojure-indent 'POST* 2)
         (put-clojure-indent 'PUT* 2)
         (put-clojure-indent 'for-all 1)
         (put-clojure-indent 'checking 2)
         (put-clojure-indent 'fdef 1)
         (put-clojure-indent 'match 1)
         (put-clojure-indent 'match-spec 2)
         (put-clojure-indent 'defcomponent '(1 nil nil (1)))
         (put-clojure-indent 'defcomponentk '(1 nil nil (1)))
         )

       )
      ;; (put-clojure-indent 'facts 1)


      (comment
        (lambda ()
          (define-clojure-indent
            (copy 2)
            (create-table 1)
            (delete 1)
            (drop-table 1)
            (insert 2)
            (select 1)
            (truncate 1)
            (update 2)
            (dom/div 2)
            (dom/ 2)
            (tdom/div 1)
            (div 1)
            (alter-var-root 1)
            (render-state 1)
            ;; storm
            (nextTuple 1)
            ;; cats
            (mlet 1)
            ;; manifold
            (let-flow 1)
            ;; riemann
            (tagged 1)
            (where 1)
            (rollup 2)
            (by 1)
            (with 1)
            (splitp 2)
            (percentiles 2)
            ;; om
            (defui '(2 nil nil (1))
              ;; core.match
              (match 1)

              ))))
    #+end_src

** Haskell
   Haskell-mode with Intero gives the best experience. Intero uses Stack.

   #+begin_src emacs-lisp :tangle yes
     (use-package haskell-mode
            :ensure t
            :config
            (progn
              (add-hook #'haskell-mode-hook
                        (lambda ()
                          (intero-mode)
                          (hindent-mode)
                          (flycheck-add-next-checker 'intero
                                                     '(warning . haskell-hlint))
                          (highlight-indentation-mode)
                          (rainbow-identifiers-mode)
                          ))))
   #+end_src

** Python
   [[https://www.python.org/static/community_logos/python-logo-generic.svg]]

   #+begin_src emacs-lisp :tangle yes
     (use-package python
       :mode ("\\.py\\'" . python-mode)
       :ensure t
       :config
       (progn ;dont invoke flycheck on temporary buffers for the interpreter
         (add-hook 'python-mode-hook
                   (lambda ()
                     (unless (eq buffer-file-name nil) (flycheck-mode 1))
                     ;; if tabs make sure they are 4 spaces wide
                     (set (make-local-variable 'tab-width) 4)
                     (jedi:setup)
                     (auto-complete-mode)
                     (highlight-indentation-mode)
                     (bind-keys :map python-mode-map
                                ("<f5>" . flycheck-previous-error)
                                ("<f6>" . flycheck-next-error)
                                ("M-/" . hippie-expand)
                                ("M-RET" . newline))
                     (font-lock-add-keywords
                      nil
                      '(("\\<\\(FIXME\\|TODO\\|BUG\\|XXX\\):" 1 font-lock-warning-face t)))))

        (setq ipython-command "/usr/local/bin/ipython")
        (setq py-python-command "/usr/local/bin/ipython")))

     (use-package jedi
       :ensure t
       :commands (jedi:setup))

     (use-package jedi-direx
       :ensure t
       :commands (jedi-direx:setup)
       :config (jedi-direx:setup))
   #+end_src

    To get jedi completion with a venv:

:     M-x venv-workon <env>
:     M-x jedi:stop-server

** Web

   Multi web mode can detect sublanguages inside html and others
   #+begin_src emacs-lisp :tangle yes
     (use-package multi-web-mode
       :ensure t
       :init
       (progn
         (setq mweb-default-major-mode 'html-mode)
         (setq mweb-tags
               '((php-mode "<\\?php\\|<\\? \\|<\\?=" "\\?>")
                 (js-mode  "<script +\\(type=\"text/javascript\"\\|language=\"javascript\"\\)[^>]*>" "</script>")
                 (jsx-mode  "<script +\\(type=\"text/jsx\"\\|language=\"jsx\"\\)[^>]*>" "</script>")
                 (css-mode "<style +type=\"text/css\"[^>]*>" "</style>")))
         (setq mweb-filename-extensions '("php" "htm" "html" "ctp" "phtml" "php4" "php5"))
         (multi-web-global-mode 1)))
   #+end_src
** Shell
   Enable flycheck (needs shellcheck installed)

   #+begin_src emacs-lisp

     (add-hook #'sh-mode-hook #'flycheck-mode)

   #+end_src
